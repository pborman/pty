// Copyright 2017 Google Inc.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package ansi

import (
	"errors"
	"io"
	"strings"
)

const (
	escape  = 033    // untyped escape code
	bell    = 007    // bell/alert
	st1     = 0234   // 1 byte string termination
	sescape = "\033" // untyped string of just an escape
)

// An S contains a decoded escape sequence.  There are several types of
// escape sequences:
//
//   "C0"  - Single Control Set 0 character 0x00 - 0x1f
//   "C1"  - Single Control Set 1 character ESC 0x40 - 0x5f / 0x80 - 0x9f
//   "ICF" - Independent Control Function ESC 0x6f - 0x7e
//   "ESC" - Other escape sequence
//   "CSI" - Standard ANSI Escape Sequence ESC [ ...
//   "CS"  - Control String
//   ""    - String of regular text (no ESC or C1 characters)
//
// CSI escape sequences may contain some number of parameters.  The parsed
// parameters are provided in Parmas.  Control Strings, such as OSC, have the
// string stored in Params[0].  Some C1 sequences take additional bytes of
// data following the sequence, such as SS2 and SS3.  In this case the
// additional data is in Params[0].
// The Code is always the canonical code (e.g., ESC [ instead of 0x9b)
type S struct {
	Type   string   // The type of sequence
	Text   string   // The actual text of the sequence
	Code   Name     // The escape sequence sans parameters (empty for text)
	Params []string // parameters
	Error  error    // Any encoutered error while processing the sequence
}

// String returns the verbatim text of s.
func (s *S) String() string {
	return s.Text
}

const (
	sos = (1 << iota) // start of string
	st                // string terminator
)

// lookup provides a quick lookup of byte attributes
var lookup = [256]byte{
	'_':  sos, // APC
	'P':  sos, // DCS
	']':  sos, // OSC
	'^':  sos, // PM
	'X':  sos, // SOS
	'\\': st,  // ST
}

// Fixed error messages generated by package ansi.
var (
	LoneEscape        = errors.New("escape at end of input")
	UnknownEscape     = errors.New("unknown escape sequence")
	NoST              = errors.New("control string missing string terminator")
	FoundSOS          = errors.New("start of string encountered in control string")
	FoundST           = errors.New("end of string encountered outside of control string")
	IncompleteCSI     = errors.New("incomplete control sequence")
	ExtraParameters   = errors.New("too many parameters for function")
	MissingParameters = errors.New("not enough parameters for function")
	BufferFull        = errors.New("escape sequence too long")
)

// flipCode flips between a one byte CS1 string and the second byte of its
// two byte equivalent.
//
// One byte codes are  100xxxxx
// Corresponding codes 010xxxx
func flipCode(c byte) byte {
	return c ^ 0xc0
}

func isC1(b byte) bool             { return b >= 0x40 && b <= 0x5f }
func isICF(b byte) bool            { return b >= 0x60 && b <= 0x7e }
func isValidFinalByte(b byte) bool { return b >= 0x40 && b <= 0x7e }
func isOneByteEscape(b byte) bool  { return b >= 0x80 && b <= 0x9f }

func isescape1(b byte) bool { return b == escape }
func isescape2(b byte) bool { return b == escape || isOneByteEscape(b) }

// bufferSize is the size of the default buffer.
const bufferSize = 32768

type Reader struct {
	buf      []byte
	r        io.Reader
	err      error  // terminating error
	b        int    // start of current sequence in buffer
	h        int    // first byte not processed in buffer
	t        int    // how many valid bytes in buffer
	e        int    // length of buf
	partial  string // used for partial reads
	isescape func(byte) bool
}

// NewReader returns a new escape decoder that reads from r with a default read
// buffer size.
func NewReader(r io.Reader) *Reader {
	return NewWithBuffer(r, make([]byte, bufferSize))
}

// NewWithBuffer returns a new escape decoder that reads from r with the
// provided buffer.
func NewWithBuffer(r io.Reader, buf []byte) *Reader {
	return &Reader{
		r:        r,
		buf:      buf,
		e:        len(buf),
		isescape: isescape1,
	}
}

// Read implements an io.Reader that strips escape sequences as it reads.
func (bp *Reader) Read(buf []byte) (int, error) {
	if len(bp.partial) > 0 {
		n := copy(buf, bp.partial)
		if len(bp.partial) == n {
			bp.partial = "" // don't hang on to the string
		} else {
			bp.partial = bp.partial[n:]
		}
		return n, nil
	}
	for {
		s, err := bp.Next()
		if err != nil {
			return 0, err
		}
		if s.Code == "" && len(s.Text) > 0 {
			bp.partial = s.Text
			return bp.Read(buf)
		}
	}
}

// Send calls Next on bp and sends the results to ch.
func (bp *Reader) Send(ch chan S) error {
	for {
		s, err := bp.Next()
		if err != nil {
			if err == io.EOF {
				return nil
			}
			return err
		}
		ch <- s
	}
}

// AllowOneByteSequences turns on processing of single byte escape
// sequences (not UNICODE safe).
func (bp *Reader) AllowOneByteSequences() {
	bp.isescape = isescape2
}

// trailingByte maps a character to true if it needs one more byte
// following the code byte.
var trailingByte = [256]bool{
	'N': true,
	'O': true,

	// Below are VT100 escape sequences that are not ANSI
	// but appear to be used by xterm
	'(': true, // Designate G0 Character Set (ISO 2022, VT100).
	')': true, // Designate G1 Character Set (ISO 2022, VT100).
	'*': true, // Designate G2 Character Set (ISO 2022, VT220).
	'+': true, // Designate G3 Character Set (ISO 2022, VT220).
	'-': true, // Designate G1 Character Set (VT300).
	'.': true, // Designate G2 Character Set (VT300).
	'/': true, // Designate G3 Character Set (VT300).
}

// Next returns either the next sequence in bp or an error.
func (bp *Reader) Next() (S, error) {
	if bp.err != nil {
		return S{}, bp.err
	}
	if err := bp.fill(1); err != nil {
		bp.err = err
		return S{}, err
	}
	// At this point there is at least one byte to be processed so
	// we know we will get back some sort of sequences.
	return bp.next(), nil
}

func (bp *Reader) next() S {
	bp.b = bp.h

	// If we have plain text, return that.
	if !bp.isescape(bp.buf[bp.b]) {
		for x, c := range bp.buf[bp.b:bp.t] {
			if bp.isescape(c) {
				return S{Text: bp.text(bp.b + x)}
			}
		}
		return S{Text: bp.text(bp.t)}
	}

	// We have an escape sequences starting at b.b

	// Set c to the escape code (byte after escape or decoded C1 byte).
	// Set h to be byte byte after the escape code.
	var c byte
	if bp.buf[bp.b] == escape {
		if err := bp.fill(2); err != nil {
			bp.h = bp.t
			return S{Text: sescape, Code: sescape, Type: "ESC", Error: LoneEscape}
		}
		c = bp.buf[bp.b+1]
		bp.h = bp.b + 2
	} else {
		c = flipCode(bp.buf[bp.b])
		bp.h = bp.b + 1
	}

	// code is the expanded escape code (e.g., 0x9b becomes ESC [)
	code := bp.code()

	// If we find the start or stop of a control string
	// just return that code.  It is the callers problem
	// to keep track of when they are in a string or not.
	switch lookup[c] {
	case 0:
	case st:
		txt := bp.text(bp.h)
		return S{Text: txt, Code: code, Type: "CS", Error: FoundST}
	default:
		// Need to find the trailing ST
		return bp.findST(code)
	}

	// buf[h] is the byte after the entry sequence (b+1 or b+2)

	switch {
	// One or two byte CSI
	case c == '[':
		return bp.processCSI()

	// SS2 or SS3 (require an extra byte)
	case trailingByte[c]:
		s := S{Code: code, Type: "ESC"}
		if err := bp.fill(1); err != nil {
			s.Error = err
		} else {
			s.Params = []string{string(bp.buf[bp.h])}
			bp.h++
		}
		s.Text = bp.text(bp.h)
		return s

	// C1 control function
	case isC1(c):
		return S{Text: bp.text(bp.h), Code: code, Type: "C1"}

	// Two byte independent control function
	case isICF(c):
		return S{Text: bp.text(bp.h), Code: code, Type: "ICF"}

	// Unknown escape sequence type
	default:
		return S{Text: bp.text(bp.h), Code: code, Type: "ESC", Error: UnknownEscape}
	}
}

func (bp *Reader) processCSI() S {
	// A CSI sequence has been encountered.  It contains:
	// 2 CSI bytes of \033[ (or a single 0x98 byte).
	// 0 or more parameters bytes (0x30 - 0x3f) followed by
	// 0 or more intermediate bytes (0x20 - 0x2f) followed by
	// 1 final byte (0x40 - 0x7e)
	//
	// (0x30 - 0x3f) "0123456789:;<=>?"
	// (0x20 - 0x2f) " !"#$%&'()*+,-./"
	// (0x40 - 0x7e) "@A-Z[\]^_`a-z{|}~"

	s := S{Type: "CSI", Code: CSI}

	// (0x30 - 0x3f) "0123456789:;<=>?"
	p0 := bp.h
	if err := bp.run(0x30, 0x3f); err != nil {
		s.Text = bp.text(bp.t)
		s.Error = err
		return s
	}
	if bp.h > p0 {
		// By the standard we should only split on ; if the
		// all the bytes are no greater than 0x3b (;).
		// Parameters that start with one of <, =, >, or ?
		// are experimental.  We will split them anyhow
		// as the caller can put them back together in the
		// off chance they didn't want them split.
		s.Params = strings.Split(string(bp.buf[p0:bp.h]), ";")
	}

	// (0x20 - 0x2f) " !"#$%&'()*+,-./"
	p1 := bp.h
	if err := bp.run(0x20, 0x2f); err != nil {
		s.Text = bp.text(bp.t)
		s.Error = err
		return s
	}
	if bp.h > p1 {
		// Add the intermediate byte(s) to the Code
		s.Code += Name(bp.buf[p1:bp.h])
	}
	if err := bp.fill(1); err != nil {
		s.Text = bp.text(bp.t)
		s.Error = err
		return s
	}

	fb := bp.buf[bp.h]
	bp.h++
	s.Code += Name(fb)
	s.Text = bp.text(bp.h)

	// Now check to see if this is a valid sequence and if so,
	// did we get the correct number of parameters?
	t := Table[s.Code]
	switch {
	case t == nil:
		// There are valid escape sequences we can't
		// lookup, such as expermimental ones.
		if !isValidFinalByte(fb) {
			s.Error = UnknownEscape
		}
	case t.NParam == 0 && len(s.Params) > 0:
		s.Error = ExtraParameters
	case len(s.Params) < t.MinParam:
		s.Error = MissingParameters
	case t.NParam == -1:
	case len(s.Params) > t.NParam:
		s.Error = ExtraParameters
	}
	return s
}

// Fill0 extends buf by one read from r.  It returns an error if there is an
// input error (such as EOF).
func (bp *Reader) fill0() error {
	if bp.t == bp.e {
		if bp.b == 0 {
			return BufferFull
		}
		bp.t = copy(bp.buf[:], bp.buf[bp.b:bp.t])
		bp.h -= bp.b
		bp.b = 0
	}
	n, err := bp.r.Read(bp.buf[bp.t:])
	bp.t += n
	return err
}

// Fill returns nil if buf contains at least count
// bytes.  It returns an error if there is an input
// error (such as EOF) before filling buf with
// count bytes.
func (bp *Reader) fill(count int) error {
	if bp.t-bp.h >= count {
		return nil
	}
	// Until we have enough bytes, or our buffer is full,
	// keep reading from the buffer.
	for {
		err := bp.fill0()
		if bp.t-bp.h >= count {
			return nil
		}
		if err != nil {
			return err
		}
	}
}

// text returns all the bytes from the begining of the buffer to j.
// the returned bytes are marked as consumed.
func (bp *Reader) text(j int) string {
	s := string(bp.buf[bp.b:j])
	bp.h = j // consume the bytes
	return s
}

// run moves h to the first byte not in the range of [start..end].  Run
// returns nil if a byte outside the range was found, BufferFull if the
// lookahead buffer is exhausted (32K escape sequence?!), or the error
// that terminated the read (typically io.EOF).
func (bp *Reader) run(start, end byte) error {
	for {
		if bp.h == bp.t {
			if err := bp.fill(1); err != nil {
				return err
			}
		}
		if bp.buf[bp.h] < start || bp.buf[bp.h] > end {
			return nil
		}
		bp.h++
	}
}

// code returns the canonical Name for the escape code in buf.
func (bp *Reader) code() Name {
	if c := bp.buf[bp.b]; c != escape {
		return Name([]byte{escape, flipCode(c)})
	}
	return Name(bp.buf[bp.b : bp.b+2])
}

func (bp *Reader) findST(code Name) S {
	for {
		// It seems xterm allows terminating with a BEL
		if err := bp.fill(1); err != nil {
			txt := bp.text(bp.t)
			return S{Text: txt, Code: code, Params: []string{txt[2:]}, Type: "CS", Error: NoST}
		}
		switch bp.buf[bp.h] {
		case escape:
		case bell, st1:
			txt := bp.text(bp.h + 1)
			return S{Text: txt, Code: code, Params: []string{txt[2:]}, Type: "CS"}
		default:
			bp.h++
			continue
		}

		// We have seen an escape. We need another byte.
		if err := bp.fill(2); err != nil {
			txt := bp.text(bp.t)
			return S{Text: txt, Code: code, Params: []string{txt[2:]}, Type: "CS", Error: NoST}
		}
		switch bp.buf[bp.h+1] {
		case 'X': // SOS
			txt := bp.text(bp.h)
			return S{Text: txt, Code: code, Params: []string{txt[2:]}, Type: "CS", Error: FoundSOS}
		case '\\': // ST
			txt := bp.text(bp.h + 2)
			return S{Text: txt, Code: code, Params: []string{txt[2:]}, Type: "CS"}
		default:
			bp.h++
		}
	}
}
