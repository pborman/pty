// Copyright 2017 Google Inc.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package ansi

import (
	"errors"
	"io"
	"strings"
)

const escape = 033

// AllowOneByteEscapeCodes enables single byte escape codes.  For example, the
// single byte 233 is equivalent to 033 [.  This is incompatible with UNICODE.
var AllowOneByteEscapeCodes = false

// An S contains a decoded escape sequence.  There are several types of
// escape sequences:
//
//   "C0"  - Single Control Set 0 character 0x00 - 0x1f
//   "C1"  - Single Control Set 1 character ESC 0x40 - 0x5f / 0x80 - 0x9f
//   "ICF" - Independent Control Function ESC 0x6f - 0x7e
//   "ESC" - Other escape sequence
//   "CSI" - Standard ANSI Escape Sequence ESC [ ...
//   "CS"  - Control String
//   ""    - String of regular text (no ESC or C1 characters)
//
// CSI escape sequences may contain some number of parameters.  The parsed
// parameters are provided in Parmas.  Control Strings, such as OSC, have the
// string stored in Params[0].  Some C1 sequences take additional bytes of
// data following the sequence, such as SS2 and SS3.  In this case the
// additional data is in Params[0].
// The Code is always the canonical code (e.g., ESC [ instead of 0x9b)
type S struct {
	Type   string   // The type of sequence
	Text   string   // The actual text of the sequence
	Code   Name     // The escape sequence sans parameters (empty for text)
	Params []string // parameters
	Error  error    // Any encoutered error while processing the sequence
}

// String returns the verbatim text of s.
func (s *S) String() string {
	return s.Text
}

const (
	sos = (1 << iota) // start of string
	st                // string terminator
)

// lookup provides a quick lookup of byte attributes
var lookup = [256]byte{
	'_':  sos, // APC
	'P':  sos, // DCS
	']':  sos, // OSC
	'^':  sos, // PM
	'X':  sos, // SOS
	'\\': st,  // ST
}

// Fixed error messages generated by package ansi.
var (
	LoneEscape        = errors.New("escape at end of input")
	UnknownEscape     = errors.New("unknown escape sequence")
	NoST              = errors.New("control string missing string terminator")
	FoundSOS          = errors.New("start of string encountered in control string")
	FoundST           = errors.New("end of string encountered outside of control string")
	IncompleteCSI     = errors.New("incomplete control sequence")
	ExtraParameters   = errors.New("too many parameters for function")
	MissingParameters = errors.New("not enough parameters for function")
	BufferFull        = errors.New("escape sequence too long")
)

// flipCode flips between a one byte CS1 string and the second byte of its
// two byte equivalent.
//
// One byte codes are  100xxxxx
// Corresponding codes 010xxxx
func flipCode(c byte) byte {
	return c ^ 0xc0
}

func isC1(b byte) bool    { return b >= 0x40 && b <= 0x5f }
func isICF(b byte) bool   { return b >= 0x60 && b <= 0x7e }
func isValid(b byte) bool { return b >= 0x40 && b <= 0x7e }
func oneByte(b byte) bool { return b >= 0x80 && b <= 0x9f }

func isescape1(b byte) bool { return b == escape }
func isescape2(b byte) bool { return b == escape || oneByte(b) }

// bufferSize is the size of the default buffer.
const bufferSize = 32768

type buffer struct {
	buf []byte
	r   io.Reader
	b   int // start of current sequence in buffer
	h   int // first byte not processed in buffer
	t   int // how many valid bytes in buffer
	e   int // length of buf
}

// Fill0 extends buf by one read from r.  It returns an error if there is an
// input error (such as EOF).
func (bp *buffer) fill0() error {
	if bp.t == bp.e {
		if bp.b == 0 {
			return BufferFull
		}
		bp.t = copy(bp.buf[:], bp.buf[bp.b:bp.t])
		bp.h -= bp.b
		bp.b = 0
	}
	n, err := bp.r.Read(bp.buf[bp.t:])
	bp.t += n
	return err
}

// Fill returns nil if buf contains at least count
// bytes.  It returns an error if there is an input
// error (such as EOF) before filling buf with
// count bytes.
func (bp *buffer) fill(count int) error {
	if bp.t-bp.h >= count {
		return nil
	}
	b, h, t, e, buf := bp.b, bp.h, bp.t, bp.e, bp.buf
	defer func() {
		bp.b, bp.h, bp.t = b, h, t
	}()
	minRead := e / 4
	for {
		switch {
		case t == b:
			b, t, h = 0, 0, 0
		case h+count > e, t+minRead > e:
			t = copy(buf, buf[b:t])
			h -= b
			b = 0
		}
		n, err := bp.r.Read(buf[t:])
		t += n
		if t-h >= count {
			return nil
		}
		if err != nil {
			return err
		}
	}
}

func (bp *buffer) text(i, j int) string {
	s := string(bp.buf[i:j])
	bp.h = j // consume the bytes
	return s
}

// run moves h to the first byte not in the range of [start..end].  Run
// returns nil if a byte outside the range was found, BufferFull if the
// lookahead buffer is exhausted (32K escape sequence?!), or the error
// that terminated the read (typically io.EOF).
func (bp *buffer) run(start, end byte) error {
	for {
		if bp.h == bp.t {
			if err := bp.fill(1); err != nil {
				return err
			}
		}
		if bp.buf[bp.h] < start || bp.buf[bp.h] > end {
			return nil
		}
		bp.h++
	}
}

// code returns the canonical Name for the escape code in buf.
func (bp *buffer) code() Name {
	if c := bp.buf[bp.b]; c != escape {
		return Name([]byte{escape, flipCode(c)})
	}
	return Name(bp.buf[bp.b : bp.b+2])
}

func (bp *buffer) findST(code Name, ch chan S) error {
	for {
		// We always need at least two bytes here.
		if err := bp.fill(2); err != nil {
			txt := bp.text(bp.b, bp.t)
			ch <- S{Text: txt, Code: code, Params: []string{txt[2:]}, Type: "CS", Error: NoST}
			return err
		}
		if bp.buf[bp.h] != escape {
			bp.h++
			continue
		}
		switch bp.buf[bp.h+1] {
		case 'X': // SOS
			txt := bp.text(bp.b, bp.h)
			ch <- S{Text: txt, Code: code, Params: []string{txt[2:]}, Type: "CS", Error: FoundSOS}
			return nil
		case '\\': // ST
			txt := bp.text(bp.b, bp.h+2)
			ch <- S{Text: txt, Code: code, Params: []string{txt[2:]}, Type: "CS"}
			return nil
		}
	}
}
func DecodeStream(r io.Reader, ch chan S) error {
	return DecodeStreamWithBuffer(r, ch, make([]byte, bufferSize))
}
func DecodeStreamWithBuffer(r io.Reader, ch chan S, buf []byte) error {
	bp := buffer{
		r:   r,
		buf: buf,
		e:   len(buf),
	}

	isescape := isescape1
	if AllowOneByteEscapeCodes {
		isescape = isescape2
	}

Processing:
	for {
		bp.b = bp.h


		if err := bp.fill(1); err != nil {
			if err == io.EOF {
				return nil
			}
			return err
		}

		// Step 2: is there a string of plain text?
		if !isescape(bp.buf[bp.b]) {
			for x, c := range bp.buf[bp.b:bp.t] {
				if isescape(c) {
					ch <- S{Text: bp.text(bp.b, bp.b+x)}
					continue Processing
				}
			}
			ch <- S{Text: bp.text(bp.b, bp.t)}
			continue Processing
		}

		// Step 3: b and h now point to an escape sequence.
		// If the first byte is ESC then it is a 2 byte
		// sequence, else it is 1 byte.

		// Set c to the escape code (byte after escape or decoded
		// C1 byte.
		var c byte
		if bp.buf[bp.b] == escape {
			if err := bp.fill(2); err != nil {
				code := bp.code()
				txt := bp.text(bp.b, bp.t)
				ch <- S{Text: txt, Code: code, Type: "ESC", Error: LoneEscape}
				return err
			}
			c = bp.buf[bp.b+1]
			bp.h = bp.b + 2
		} else {
			c = flipCode(bp.buf[bp.b])
			bp.h = bp.b + 1
		}

		// code is the expanded escape code (e.g., 0x9b becomes ESC [)
		code := bp.code()

		// If we find the start or stop of a control string
		// just return that code.  It is the callers problem
		// to keep track of when they are in a string or not.
		switch lookup[c] {
		case 0:
		case st:
			txt := bp.text(bp.b, bp.h)
			ch <- S{Text: txt, Code: code, Type: "CS", Error: FoundST}
			continue Processing
		default:
			// Need to find the trailing ST
			if err := bp.findST(code, ch); err != nil {
				return err
			}
			continue Processing
		}

		// buf[h] is the byte after the entry sequence (b+1 or b+2)

		switch {
		// One or two byte CSI
		case c == '[':

		// SS2 or SS3 (require an extra byte)
		case c == 'N', c == 'O':
			s := S{Code: code, Type: "ESC"}
			if err := bp.fill(1); err != nil {
				s.Error = err
			} else {
				s.Params = []string{string(bp.buf[bp.h])}
				bp.h++
			}
			s.Text = bp.text(bp.b, bp.h)
			ch <- s
			continue Processing

		// C1 control function
		case isC1(c):
			ch <- S{Text: bp.text(bp.b, bp.h), Code: code, Type: "C1"}
			continue Processing

		// Two byte independent control function
		case isICF(c):
			ch <- S{Text: bp.text(bp.b, bp.h), Code: code, Type: "ICF"}
			continue Processing

		// Unknown escape sequence type
		default:
			ch <- S{Text: bp.text(bp.b, bp.h), Code: code, Type: "ESC", Error: UnknownEscape}
			continue Processing
		}

		// A CSI sequence has been encountered.  It contains:
		// 2 CSI bytes of \033[ (or a single 0x98 byte).
		// 0 or more parameters bytes (0x30 - 0x3f) followed by
		// 0 or more intermediate bytes (0x20 - 0x2f) followed by
		// 1 final byte (0x40 - 0x7e)
		//
		// (0x30 - 0x3f) "0123456789:;<=>?"
		// (0x20 - 0x2f) " !"#$%&'()*+,-./"
		// (0x40 - 0x7e) "@A-Z[\]^_`a-z{|}~"

		s := S{Type: "CSI", Code: CSI}

		// (0x30 - 0x3f) "0123456789:;<=>?"
		p0 := bp.h
		if err := bp.run(0x30, 0x3f); err != nil {
			s.Text = bp.text(bp.b, bp.t)
			s.Error = err
			ch <- s
			continue Processing
		}
		if bp.h > p0 {
			// By the standard we should only split on ; if the
			// all the bytes are no greater than 0x3b (;).
			// Parameters that start with one of <, =, >, or ?
			// are experimental.  We will split them anyhow
			// as the caller can put them back together in the
			// off chance they didn't want them split.
			s.Params = strings.Split(string(bp.buf[p0:bp.h]), ";")
		}

		// (0x20 - 0x2f) " !"#$%&'()*+,-./"
		p1 := bp.h
		if err := bp.run(0x20, 0x2f); err != nil {
			s.Text = bp.text(bp.b, bp.t)
			s.Error = err
			ch <- s
			continue Processing
		}
		if bp.h > p1 {
			// Add the intermediate byte(s) to the Code
			s.Code += Name(bp.buf[p1:bp.h])
		}
		if err := bp.fill(1); err != nil {
			s.Text = bp.text(bp.b, bp.t)
			s.Error = err
			ch <- s
			return err
		}

		fb := bp.buf[bp.h]
		bp.h++
		s.Code += Name(fb)
		s.Text = bp.text(bp.b, bp.h)

		// Now check to see if this is a valid sequence and if so,
		// did we get the correct number of parameters?
		t := Table[s.Code]
		switch {
		case t == nil:
			// There are valid escape sequences we can't
			// lookup, such as expermimental ones.
			if !isValid(fb) {
				s.Error = UnknownEscape
			}
		case t.NParam == 0 && len(s.Params) > 0:
			s.Error = ExtraParameters
		case len(s.Params) < t.MinParam:
			s.Error = MissingParameters
		case t.NParam == -1:
		case len(s.Params) > t.NParam:
			s.Error = ExtraParameters
		}
		ch <- s
	}
}
