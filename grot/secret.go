package main

import (
	"bytes"
	"crypto/rand"
	"crypto/sha512"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"

	"golang.org/x/crypto/ssh/terminal"
)

const (
	SecretFile = rcdir + "/secret"
)

// GetSecret returns a secret derived by hashing the contents of the user's
// SecretFile appended with the provided password.  An error is returned if the
// file cannot be read or the file has too lax of priviledges.
func GetSecret(password []byte) ([]byte, error) {
	path := filepath.Join(user.HomeDir, SecretFile)
	fi, err := os.Stat(path)
	if err != nil {
		return nil, err
	}
	if fi.Mode()&077 != 0 {
		return nil, fmt.Errorf("%s: insufficient security, accessible by other users", path)
	}
	data, err := ioutil.ReadFile(path)
	if err != nil {
		return nil, err
	}
	sum := sha512.Sum512(append(data, password...))
	return sum[:], nil
}

// MakeSecret generates the user's SecretFile with random data, replacing
// any existing file.
func MakeSecret() error {
	os.Mkdir(filepath.Join(user.HomeDir, rcdir), 0700)
	path := filepath.Join(user.HomeDir, SecretFile)
	os.Remove(path)
	var data [64]byte
	if _, err := rand.Read(data[:]); err != nil {
		return err
	}
	os.Remove(path)
	fd, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0400)
	if err != nil {
		return err
	}
	defer fd.Close()
	if _, err := fd.Write(data[:]); err != nil {
		return err
	}
	return nil
}

// CheckSecret returns with no error if data matches the secret generated by
// GetSecret, an error otherwise.
func CheckSecret(password, data []byte) error {
	secret, err := GetSecret(password)
	if err != nil {
		return err
	}
	if !bytes.Equal(secret, data) {
		return fmt.Errorf("invalid secret password")
	}
	return nil
}

func ReadPassword(prompt string, r io.Reader) ([]byte, error) {
	if fd, ok := r.(*os.File); ok {
		fd.Write([]byte(prompt))
		data, err := terminal.ReadPassword(int(fd.Fd()))
		fd.Write([]byte("\n"))
		return data, err
	}
	data := make([]byte, 64)
	i := 0
	for {
		if len(data) == i {
			ndata := make([]byte, len(data)+64)
			copy(ndata, data)
			data = ndata
		}
		if _, err := r.Read(data[i : i+1]); err != nil {
			if err == io.EOF {
				return data[:i], nil
			}
			return nil, err
		}
		if data[i] == '\n' {
			return data[:i], nil
		}
	}
}

func GetNewPassword(tty *os.File) ([]byte, error) {
	print := func(s string) { tty.Write([]byte(s)) }

	for i := 0; i < 3; i++ {
		print("Enter new ")
		p1, err := ReadPassword("Enter new password: ", tty)
		if err != nil {
			return nil, err
		}
		if len(p1) < 8 {
			print("Password too short.  Try again.\n")
			continue
		}
		p2, err := ReadPassword("Re-enter new password: ", tty)
		if err != nil {
			return nil, err
		}
		if bytes.Equal(p1, p2) {
			return p1, nil
		}
		print("Passwords did not match.  Try again.\n")
	}
	return nil, fmt.Errorf("too many failures")
}
